// Proof-of-Useful-Work (PoUW) protocol buffer definitions.
//
// INTEGRATION BOUNDARY: These protobuf types define the shared data contract
// between the Go blockchain (Cosmos SDK) and Rust services (crates/).
//
// Go compilation: protoc generates Go types into x/pouw/types/
// Rust compilation: Rust services use prost or manual structs matching these schemas.
//
// Communication path:
//   User TX --> Go Chain (x/pouw/keeper) --> ABCI++ Vote Extensions --> TEE Worker (Rust, HTTP/gRPC)
//   TEE Worker --> Attestation + Result --> Go Chain --> Digital Seal (x/seal)
//
// The Go chain is the source of truth for state. Rust services are stateless workers
// that execute computations and return attestations.
//
// PoUW (Proof-of-Useful-Work) is Aethelred's novel consensus mechanism that:
// - Verifies AI computations cryptographically
// - Rewards validators based on utility category multipliers
// - Uses logarithmic scaling to prevent stake concentration
// - Supports hybrid TEE + zkML verification

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.3
// source: aethelred/pouw/v1/pouw.proto

package types

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Msg_SubmitJob_FullMethodName                   = "/aethelred.pouw.v1.Msg/SubmitJob"
	Msg_RegisterModel_FullMethodName               = "/aethelred.pouw.v1.Msg/RegisterModel"
	Msg_CancelJob_FullMethodName                   = "/aethelred.pouw.v1.Msg/CancelJob"
	Msg_RegisterValidatorCapability_FullMethodName = "/aethelred.pouw.v1.Msg/RegisterValidatorCapability"
	Msg_RegisterValidatorPCR0_FullMethodName       = "/aethelred.pouw.v1.Msg/RegisterValidatorPCR0"
)

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Msg service
type MsgClient interface {
	SubmitJob(ctx context.Context, in *MsgSubmitJob, opts ...grpc.CallOption) (*MsgSubmitJobResponse, error)
	RegisterModel(ctx context.Context, in *MsgRegisterModel, opts ...grpc.CallOption) (*MsgRegisterModelResponse, error)
	CancelJob(ctx context.Context, in *MsgCancelJob, opts ...grpc.CallOption) (*MsgCancelJobResponse, error)
	RegisterValidatorCapability(ctx context.Context, in *MsgRegisterValidatorCapability, opts ...grpc.CallOption) (*MsgRegisterValidatorCapabilityResponse, error)
	RegisterValidatorPCR0(ctx context.Context, in *MsgRegisterValidatorPCR0, opts ...grpc.CallOption) (*MsgRegisterValidatorPCR0Response, error)
}

type msgClient struct {
	cc grpc.ClientConnInterface
}

func NewMsgClient(cc grpc.ClientConnInterface) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) SubmitJob(ctx context.Context, in *MsgSubmitJob, opts ...grpc.CallOption) (*MsgSubmitJobResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgSubmitJobResponse)
	err := c.cc.Invoke(ctx, Msg_SubmitJob_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RegisterModel(ctx context.Context, in *MsgRegisterModel, opts ...grpc.CallOption) (*MsgRegisterModelResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgRegisterModelResponse)
	err := c.cc.Invoke(ctx, Msg_RegisterModel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CancelJob(ctx context.Context, in *MsgCancelJob, opts ...grpc.CallOption) (*MsgCancelJobResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgCancelJobResponse)
	err := c.cc.Invoke(ctx, Msg_CancelJob_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RegisterValidatorCapability(ctx context.Context, in *MsgRegisterValidatorCapability, opts ...grpc.CallOption) (*MsgRegisterValidatorCapabilityResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgRegisterValidatorCapabilityResponse)
	err := c.cc.Invoke(ctx, Msg_RegisterValidatorCapability_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RegisterValidatorPCR0(ctx context.Context, in *MsgRegisterValidatorPCR0, opts ...grpc.CallOption) (*MsgRegisterValidatorPCR0Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgRegisterValidatorPCR0Response)
	err := c.cc.Invoke(ctx, Msg_RegisterValidatorPCR0_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
// All implementations must embed UnimplementedMsgServer
// for forward compatibility.
//
// Msg service
type MsgServer interface {
	SubmitJob(context.Context, *MsgSubmitJob) (*MsgSubmitJobResponse, error)
	RegisterModel(context.Context, *MsgRegisterModel) (*MsgRegisterModelResponse, error)
	CancelJob(context.Context, *MsgCancelJob) (*MsgCancelJobResponse, error)
	RegisterValidatorCapability(context.Context, *MsgRegisterValidatorCapability) (*MsgRegisterValidatorCapabilityResponse, error)
	RegisterValidatorPCR0(context.Context, *MsgRegisterValidatorPCR0) (*MsgRegisterValidatorPCR0Response, error)
	mustEmbedUnimplementedMsgServer()
}

// UnimplementedMsgServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMsgServer struct{}

func (UnimplementedMsgServer) SubmitJob(context.Context, *MsgSubmitJob) (*MsgSubmitJobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitJob not implemented")
}
func (UnimplementedMsgServer) RegisterModel(context.Context, *MsgRegisterModel) (*MsgRegisterModelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterModel not implemented")
}
func (UnimplementedMsgServer) CancelJob(context.Context, *MsgCancelJob) (*MsgCancelJobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelJob not implemented")
}
func (UnimplementedMsgServer) RegisterValidatorCapability(context.Context, *MsgRegisterValidatorCapability) (*MsgRegisterValidatorCapabilityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterValidatorCapability not implemented")
}
func (UnimplementedMsgServer) RegisterValidatorPCR0(context.Context, *MsgRegisterValidatorPCR0) (*MsgRegisterValidatorPCR0Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterValidatorPCR0 not implemented")
}
func (UnimplementedMsgServer) mustEmbedUnimplementedMsgServer() {}
func (UnimplementedMsgServer) testEmbeddedByValue()             {}

// UnsafeMsgServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MsgServer will
// result in compilation errors.
type UnsafeMsgServer interface {
	mustEmbedUnimplementedMsgServer()
}

func RegisterMsgServer(s grpc.ServiceRegistrar, srv MsgServer) {
	// If the following call pancis, it indicates UnimplementedMsgServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Msg_ServiceDesc, srv)
}

func _Msg_SubmitJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSubmitJob)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SubmitJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_SubmitJob_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SubmitJob(ctx, req.(*MsgSubmitJob))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RegisterModel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRegisterModel)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RegisterModel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_RegisterModel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RegisterModel(ctx, req.(*MsgRegisterModel))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CancelJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCancelJob)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CancelJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_CancelJob_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CancelJob(ctx, req.(*MsgCancelJob))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RegisterValidatorCapability_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRegisterValidatorCapability)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RegisterValidatorCapability(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_RegisterValidatorCapability_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RegisterValidatorCapability(ctx, req.(*MsgRegisterValidatorCapability))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RegisterValidatorPCR0_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRegisterValidatorPCR0)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RegisterValidatorPCR0(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_RegisterValidatorPCR0_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RegisterValidatorPCR0(ctx, req.(*MsgRegisterValidatorPCR0))
	}
	return interceptor(ctx, in, info, handler)
}

// Msg_ServiceDesc is the grpc.ServiceDesc for Msg service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Msg_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aethelred.pouw.v1.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SubmitJob",
			Handler:    _Msg_SubmitJob_Handler,
		},
		{
			MethodName: "RegisterModel",
			Handler:    _Msg_RegisterModel_Handler,
		},
		{
			MethodName: "CancelJob",
			Handler:    _Msg_CancelJob_Handler,
		},
		{
			MethodName: "RegisterValidatorCapability",
			Handler:    _Msg_RegisterValidatorCapability_Handler,
		},
		{
			MethodName: "RegisterValidatorPCR0",
			Handler:    _Msg_RegisterValidatorPCR0_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aethelred/pouw/v1/pouw.proto",
}

const (
	Query_Job_FullMethodName              = "/aethelred.pouw.v1.Query/Job"
	Query_Jobs_FullMethodName             = "/aethelred.pouw.v1.Query/Jobs"
	Query_PendingJobs_FullMethodName      = "/aethelred.pouw.v1.Query/PendingJobs"
	Query_Model_FullMethodName            = "/aethelred.pouw.v1.Query/Model"
	Query_ValidatorStats_FullMethodName   = "/aethelred.pouw.v1.Query/ValidatorStats"
	Query_Params_FullMethodName           = "/aethelred.pouw.v1.Query/Params"
	Query_ValidatorPCR0_FullMethodName    = "/aethelred.pouw.v1.Query/ValidatorPCR0"
	Query_IsPCR0Registered_FullMethodName = "/aethelred.pouw.v1.Query/IsPCR0Registered"
	Query_UsefulWorkStats_FullMethodName  = "/aethelred.pouw.v1.Query/UsefulWorkStats"
	Query_EpochStats_FullMethodName       = "/aethelred.pouw.v1.Query/EpochStats"
)

// QueryClient is the client API for Query service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Query service
type QueryClient interface {
	Job(ctx context.Context, in *QueryJobRequest, opts ...grpc.CallOption) (*QueryJobResponse, error)
	Jobs(ctx context.Context, in *QueryJobsRequest, opts ...grpc.CallOption) (*QueryJobsResponse, error)
	PendingJobs(ctx context.Context, in *QueryPendingJobsRequest, opts ...grpc.CallOption) (*QueryPendingJobsResponse, error)
	Model(ctx context.Context, in *QueryModelRequest, opts ...grpc.CallOption) (*QueryModelResponse, error)
	ValidatorStats(ctx context.Context, in *QueryValidatorStatsRequest, opts ...grpc.CallOption) (*QueryValidatorStatsResponse, error)
	Params(ctx context.Context, in *QueryParamsRequest, opts ...grpc.CallOption) (*QueryParamsResponse, error)
	ValidatorPCR0(ctx context.Context, in *QueryValidatorPCR0Request, opts ...grpc.CallOption) (*QueryValidatorPCR0Response, error)
	IsPCR0Registered(ctx context.Context, in *QueryIsPCR0RegisteredRequest, opts ...grpc.CallOption) (*QueryIsPCR0RegisteredResponse, error)
	UsefulWorkStats(ctx context.Context, in *QueryUsefulWorkStatsRequest, opts ...grpc.CallOption) (*QueryUsefulWorkStatsResponse, error)
	EpochStats(ctx context.Context, in *QueryEpochStatsRequest, opts ...grpc.CallOption) (*QueryEpochStatsResponse, error)
}

type queryClient struct {
	cc grpc.ClientConnInterface
}

func NewQueryClient(cc grpc.ClientConnInterface) QueryClient {
	return &queryClient{cc}
}

func (c *queryClient) Job(ctx context.Context, in *QueryJobRequest, opts ...grpc.CallOption) (*QueryJobResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryJobResponse)
	err := c.cc.Invoke(ctx, Query_Job_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) Jobs(ctx context.Context, in *QueryJobsRequest, opts ...grpc.CallOption) (*QueryJobsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryJobsResponse)
	err := c.cc.Invoke(ctx, Query_Jobs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) PendingJobs(ctx context.Context, in *QueryPendingJobsRequest, opts ...grpc.CallOption) (*QueryPendingJobsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryPendingJobsResponse)
	err := c.cc.Invoke(ctx, Query_PendingJobs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) Model(ctx context.Context, in *QueryModelRequest, opts ...grpc.CallOption) (*QueryModelResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryModelResponse)
	err := c.cc.Invoke(ctx, Query_Model_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) ValidatorStats(ctx context.Context, in *QueryValidatorStatsRequest, opts ...grpc.CallOption) (*QueryValidatorStatsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryValidatorStatsResponse)
	err := c.cc.Invoke(ctx, Query_ValidatorStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) Params(ctx context.Context, in *QueryParamsRequest, opts ...grpc.CallOption) (*QueryParamsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryParamsResponse)
	err := c.cc.Invoke(ctx, Query_Params_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) ValidatorPCR0(ctx context.Context, in *QueryValidatorPCR0Request, opts ...grpc.CallOption) (*QueryValidatorPCR0Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryValidatorPCR0Response)
	err := c.cc.Invoke(ctx, Query_ValidatorPCR0_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) IsPCR0Registered(ctx context.Context, in *QueryIsPCR0RegisteredRequest, opts ...grpc.CallOption) (*QueryIsPCR0RegisteredResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryIsPCR0RegisteredResponse)
	err := c.cc.Invoke(ctx, Query_IsPCR0Registered_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) UsefulWorkStats(ctx context.Context, in *QueryUsefulWorkStatsRequest, opts ...grpc.CallOption) (*QueryUsefulWorkStatsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryUsefulWorkStatsResponse)
	err := c.cc.Invoke(ctx, Query_UsefulWorkStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) EpochStats(ctx context.Context, in *QueryEpochStatsRequest, opts ...grpc.CallOption) (*QueryEpochStatsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryEpochStatsResponse)
	err := c.cc.Invoke(ctx, Query_EpochStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QueryServer is the server API for Query service.
// All implementations must embed UnimplementedQueryServer
// for forward compatibility.
//
// Query service
type QueryServer interface {
	Job(context.Context, *QueryJobRequest) (*QueryJobResponse, error)
	Jobs(context.Context, *QueryJobsRequest) (*QueryJobsResponse, error)
	PendingJobs(context.Context, *QueryPendingJobsRequest) (*QueryPendingJobsResponse, error)
	Model(context.Context, *QueryModelRequest) (*QueryModelResponse, error)
	ValidatorStats(context.Context, *QueryValidatorStatsRequest) (*QueryValidatorStatsResponse, error)
	Params(context.Context, *QueryParamsRequest) (*QueryParamsResponse, error)
	ValidatorPCR0(context.Context, *QueryValidatorPCR0Request) (*QueryValidatorPCR0Response, error)
	IsPCR0Registered(context.Context, *QueryIsPCR0RegisteredRequest) (*QueryIsPCR0RegisteredResponse, error)
	UsefulWorkStats(context.Context, *QueryUsefulWorkStatsRequest) (*QueryUsefulWorkStatsResponse, error)
	EpochStats(context.Context, *QueryEpochStatsRequest) (*QueryEpochStatsResponse, error)
	mustEmbedUnimplementedQueryServer()
}

// UnimplementedQueryServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedQueryServer struct{}

func (UnimplementedQueryServer) Job(context.Context, *QueryJobRequest) (*QueryJobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Job not implemented")
}
func (UnimplementedQueryServer) Jobs(context.Context, *QueryJobsRequest) (*QueryJobsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Jobs not implemented")
}
func (UnimplementedQueryServer) PendingJobs(context.Context, *QueryPendingJobsRequest) (*QueryPendingJobsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PendingJobs not implemented")
}
func (UnimplementedQueryServer) Model(context.Context, *QueryModelRequest) (*QueryModelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Model not implemented")
}
func (UnimplementedQueryServer) ValidatorStats(context.Context, *QueryValidatorStatsRequest) (*QueryValidatorStatsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidatorStats not implemented")
}
func (UnimplementedQueryServer) Params(context.Context, *QueryParamsRequest) (*QueryParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Params not implemented")
}
func (UnimplementedQueryServer) ValidatorPCR0(context.Context, *QueryValidatorPCR0Request) (*QueryValidatorPCR0Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidatorPCR0 not implemented")
}
func (UnimplementedQueryServer) IsPCR0Registered(context.Context, *QueryIsPCR0RegisteredRequest) (*QueryIsPCR0RegisteredResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsPCR0Registered not implemented")
}
func (UnimplementedQueryServer) UsefulWorkStats(context.Context, *QueryUsefulWorkStatsRequest) (*QueryUsefulWorkStatsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UsefulWorkStats not implemented")
}
func (UnimplementedQueryServer) EpochStats(context.Context, *QueryEpochStatsRequest) (*QueryEpochStatsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EpochStats not implemented")
}
func (UnimplementedQueryServer) mustEmbedUnimplementedQueryServer() {}
func (UnimplementedQueryServer) testEmbeddedByValue()               {}

// UnsafeQueryServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to QueryServer will
// result in compilation errors.
type UnsafeQueryServer interface {
	mustEmbedUnimplementedQueryServer()
}

func RegisterQueryServer(s grpc.ServiceRegistrar, srv QueryServer) {
	// If the following call pancis, it indicates UnimplementedQueryServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Query_ServiceDesc, srv)
}

func _Query_Job_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Job(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_Job_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Job(ctx, req.(*QueryJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_Jobs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryJobsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Jobs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_Jobs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Jobs(ctx, req.(*QueryJobsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_PendingJobs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryPendingJobsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).PendingJobs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_PendingJobs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).PendingJobs(ctx, req.(*QueryPendingJobsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_Model_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryModelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Model(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_Model_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Model(ctx, req.(*QueryModelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_ValidatorStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryValidatorStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).ValidatorStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_ValidatorStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).ValidatorStats(ctx, req.(*QueryValidatorStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_Params_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryParamsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Params(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_Params_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Params(ctx, req.(*QueryParamsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_ValidatorPCR0_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryValidatorPCR0Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).ValidatorPCR0(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_ValidatorPCR0_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).ValidatorPCR0(ctx, req.(*QueryValidatorPCR0Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_IsPCR0Registered_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryIsPCR0RegisteredRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).IsPCR0Registered(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_IsPCR0Registered_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).IsPCR0Registered(ctx, req.(*QueryIsPCR0RegisteredRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_UsefulWorkStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryUsefulWorkStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).UsefulWorkStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_UsefulWorkStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).UsefulWorkStats(ctx, req.(*QueryUsefulWorkStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_EpochStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryEpochStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).EpochStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_EpochStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).EpochStats(ctx, req.(*QueryEpochStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Query_ServiceDesc is the grpc.ServiceDesc for Query service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Query_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aethelred.pouw.v1.Query",
	HandlerType: (*QueryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Job",
			Handler:    _Query_Job_Handler,
		},
		{
			MethodName: "Jobs",
			Handler:    _Query_Jobs_Handler,
		},
		{
			MethodName: "PendingJobs",
			Handler:    _Query_PendingJobs_Handler,
		},
		{
			MethodName: "Model",
			Handler:    _Query_Model_Handler,
		},
		{
			MethodName: "ValidatorStats",
			Handler:    _Query_ValidatorStats_Handler,
		},
		{
			MethodName: "Params",
			Handler:    _Query_Params_Handler,
		},
		{
			MethodName: "ValidatorPCR0",
			Handler:    _Query_ValidatorPCR0_Handler,
		},
		{
			MethodName: "IsPCR0Registered",
			Handler:    _Query_IsPCR0Registered_Handler,
		},
		{
			MethodName: "UsefulWorkStats",
			Handler:    _Query_UsefulWorkStats_Handler,
		},
		{
			MethodName: "EpochStats",
			Handler:    _Query_EpochStats_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aethelred/pouw/v1/pouw.proto",
}
